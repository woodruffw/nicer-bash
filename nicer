#!/usr/bin/env bash

# convenience output functions

function error {
	printf "ERROR: ${*}\n"
}

alias err=error

function error! {
	>&2 printf "ERROR: ${*}\n"
}

alias err!=error!

function warn {
	printf "WARNING: ${*}\n"
}

function warn! {
	>&2 printf "WARNING: ${*}\n"
}

function info {
	printf "INFO: ${*}\n"
}

function info! {
	>&2 printf "INFO: ${*}\n"
}

# file/string checking functions

function exists? {
	return $([[ -e ${1} ]])
}

function file? {
	return $([[ -f ${1} ]])
}

function directory? {
	return $([[ -d ${1} ]])
}

alias dir?=directory?

function readable? {
	return $([[ -r ${1} ]])
}

alias read?=readable?

function writeable? {
	return $([[ -w ${1} ]])
}

alias write?=writeable?

function executable? {
	return $([[ -x ${1} ]])
}

alias exec?=executable?

function empty? {
	return $([[ -z ${1} ]])
}

function nonempty? {
	return $([[ -n ${1} ]])
}

# dependency/compatibility functions

function installed? {
	# TODO: `which` is not POSIX, so this should be changed to `command -v`
	# because `command -v` also picks up on aliases/functions, existence also
	# needs to be checked.
	return $(which ${1} > /dev/null)
}

function require {
	case "${1}" in
		bash2 )	return $([[ "${BASH_VERSINFO[0]}" -ge 2 ]]) ;;
		bash3 )	return $([[ "${BASH_VERSINFO[0]}" -ge 3 ]]) ;;
		bash4 )	return $([[ "${BASH_VERSINFO[0]}" -ge 4 ]]) ;;
		"" ) error! "require: missing requirement" ; return 1 ;;
		* ) error! "require: unknown requirement '${1}'" ; return 1 ;;
	esac
}

function require! {
	if nonempty? "${1}"; then
		require "${1}" || (error! "unsatisfied requirement: ${1}" && return 1)
	else
		error! "require: missing requirement"
		return 1
	fi
}
